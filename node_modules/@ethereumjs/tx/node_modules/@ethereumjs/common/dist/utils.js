"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGethGenesis = void 0;
const util_1 = require("@ethereumjs/util");
const enums_1 = require("./enums");
/**
 * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally
 * @param nonce string parsed from the Geth genesis file
 * @returns nonce as a 0x-prefixed 8 byte string
 */
function formatNonce(nonce) {
    if (!nonce || nonce === '0x0') {
        return '0x0000000000000000';
    }
    if ((0, util_1.isHexPrefixed)(nonce)) {
        return '0x' + (0, util_1.stripHexPrefix)(nonce).padStart(16, '0');
    }
    return '0x' + nonce.padStart(16, '0');
}
/**
 * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object
 * @param json object representing the Geth genesis file
 * @returns genesis parameters in a `CommonOpts` compliant object
 */
function parseGethParams(json) {
    const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas } = json;
    let { extraData, timestamp, nonce } = json;
    const { chainId } = config;
    // geth is not strictly putting empty fields with a 0x prefix
    if (extraData === '') {
        extraData = '0x';
    }
    // geth may use number for timestamp
    if (!(0, util_1.isHexPrefixed)(timestamp)) {
        timestamp = (0, util_1.intToHex)(parseInt(timestamp));
    }
    // geth may not give us a nonce strictly formatted to an 8 byte hex string
    if (nonce.length !== 18) {
        nonce = formatNonce(nonce);
    }
    // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time
    // but have different configuration parameters in geth genesis parameters
    if (config.eip155Block !== config.eip158Block) {
        throw new Error('EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork');
    }
    const params = {
        name,
        chainId,
        networkId: chainId,
        genesis: {
            timestamp,
            gasLimit: parseInt(gasLimit),
            difficulty: parseInt(difficulty),
            nonce,
            extraData,
            mixHash,
            coinbase,
            baseFeePerGas,
        },
        bootstrapNodes: [],
        consensus: config.clique !== undefined
            ? {
                type: 'poa',
                algorithm: 'clique',
                clique: {
                    period: config.clique.period,
                    epoch: config.clique.epoch,
                },
            }
            : {
                type: 'pow',
                algorithm: 'ethash',
                ethash: {},
            },
    };
    const forkMap = {
        [enums_1.Hardfork.Homestead]: 'homesteadBlock',
        [enums_1.Hardfork.Dao]: 'daoForkBlock',
        [enums_1.Hardfork.TangerineWhistle]: 'eip150Block',
        [enums_1.Hardfork.SpuriousDragon]: 'eip155Block',
        [enums_1.Hardfork.Byzantium]: 'byzantiumBlock',
        [enums_1.Hardfork.Constantinople]: 'constantinopleBlock',
        [enums_1.Hardfork.Petersburg]: 'petersburgBlock',
        [enums_1.Hardfork.Istanbul]: 'istanbulBlock',
        [enums_1.Hardfork.MuirGlacier]: 'muirGlacierBlock',
        [enums_1.Hardfork.Berlin]: 'berlinBlock',
        [enums_1.Hardfork.London]: 'londonBlock',
        [enums_1.Hardfork.MergeForkIdTransition]: 'mergeForkBlock',
    };
    params.hardforks = Object.values(enums_1.Hardfork)
        .map((name) => ({
        name,
        block: name === enums_1.Hardfork.Chainstart ? 0 : config[forkMap[name]] ?? null,
    }))
        .filter((fork) => fork.block !== null);
    if (config.terminalTotalDifficulty !== undefined) {
        params.hardforks.push({
            name: enums_1.Hardfork.Merge,
            ttd: config.terminalTotalDifficulty,
            block: null,
        });
    }
    return params;
}
/**
 * Parses a genesis.json exported from Geth into parameters for Common instance
 * @param json representing the Geth genesis file
 * @param name optional chain name
 * @returns parsed params
 */
function parseGethGenesis(json, name) {
    try {
        if (['config', 'difficulty', 'gasLimit', 'alloc'].some((field) => !(field in json))) {
            throw new Error('Invalid format, expected geth genesis fields missing');
        }
        if (name !== undefined) {
            json.name = name;
        }
        return parseGethParams(json);
    }
    catch (e) {
        throw new Error(`Error parsing parameters file: ${e.message}`);
    }
}
exports.parseGethGenesis = parseGethGenesis;
//# sourceMappingURL=utils.js.map